# 코딩테스트 이론 정리
**목차**
+ [효율적인 코딩테스트 방식](##효율적인-코딩테스트-방식)
+ [시간복잡도와 알고리즘](##시간복잡도와-알고리즘)
+ [코딩테스트 문제 유형](##코딩테스트-문제-유형)

---
## 효율적인 코딩테스트 방식
[참고자료: 코딩테스트합격자되기(자바편) wikidocs](https://wikidocs.net/book/14549)

+ 문제 분석
    + 전체 시간의 50~60%는 문제 분석에 시간을 들여라 (핵심 키워드 파악)
    + 문제를 동작단위로 분할해서 분석하라
    + 분석 단계에서 제약사항을 정리 후 테스트 케이스를 추가하라
    + 입력값을 분석하여 제한시간 내에 불가능한 알고리즘(시간복잡도)를 제외하라
    + 탐욕법(그리디)을 적용할 문제는 신중하게 검토 후 논리적 오류가 없을 때만 적용하라
    + 데이터 흐름 및 구성을 파악하라


+ 의사 코드로 설계
    + 세부 구현이 아닌 동작 중심으로 작성
    + 문제 해결 순서대로 작성
    + 세부 구현 전 테스트 필수

---
## 시간복잡도와 알고리즘
코딩 테스트 문제에는 제한 시간이 있으므로 문제를 분석한 후에 빅오 표기법을 활용해서 해당 알고리즘을 적용했을 때 제한 시간 내에 출력값
연산 횟수는 1,000~3,000만 정도로 고려해서 시간 복잡도를 생각

+ 코딩테스트의 제한 시간 내에 적용한 알고리즘에서 출력값을 도출해야 함
+ 연산 횟수 1,000~3,000만 정도로 고려하여 제한 시간 1초 내에 시간복잡도 별 N의 가용범위를 계산

| 시간복잡도     | N의 가용범위     |
|-----------|-------------|
| $O(N!)$   | 10          |
| $O(2^N)$  | 20~25       |
| $O(N^3)$  | 200~300     |
| $O(N^2)$  | 3,000~5,000 |
| $O(NlogN)$ | 100만        |
| $O(N)$    | 1,000~2,000 |
| $O(logN)$ | 10억         |

_EX. 데이터가 N개인 배열에서 특정 값 찾기_
``` java
    // 시간복잡도 = O(N)
    for(int index = 0; index < array.length; index++) {
        if(array[index] == x) {
            System.out.println("값 " + x + "는 배열 " + index + "번 째에 저장");
            break;
        }
    }
```
_입력값, 배열의 크기가 1,000개 미만이면 위 알고리즘 사용 가능, 2,000개 이상이면 사용 불가_

---
## 코딩테스트 문제 유형

### 자료구조 문제

특정 자료구조에 대한 지식 활용
+ Arrays
+ ArrayList
+ String / StringBuilder / StringBuffer
+ Stack
+ Queue
+ Tree
+ Heap
+ HashMap


### 알고리즘 문제
완전탐색/분할정복/탐욕법/동적계획법(DP) 패러다임 문제
+ 완전탐색
  + BFS(너비우선탐색)
  + DFS(깊이우선탐색) 
  + BackTracking 
+ 분할정복
  + 이진탐색
+ 탐욕법
  + 균형맞추기 문제
  + 구간덮기 문제
+ 동적계획법(DP)
  + 최적화/경우의 수 문제

### 기타 구현 문제
+ 객체 Sort --> compare( ) 메서드를 사용
```java
    Arrays.sort(ref, new Comparator<ReferSome>() {
        @Override
        public int compare(ReferSome r1, ReferSome r2) {
          return Integer.compare(r1.rank, r2.rank);
        }
      }); 
```
